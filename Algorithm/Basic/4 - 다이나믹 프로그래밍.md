# 4. 다이나믹 프로그래밍

큰 문제를 작은 문제로 나눠서 푸는 알고리즘

**동적 계획법** 이라고 번역되지만, 다이나믹 프로그래밍을 만든 리처드 벨만은 그냥 Dynamic 이 간지나서 썻다고 한다. 너무 의미를 두지 말자.



## 다이나믹 프로그래밍 조건

다음 두가지 속성을 만족합니다.

##### 1. Overlapping Subproblem 

겹치는 부분 문제를 말합니다.

##### 2. Optimal Substructure 

문제의 정답을 작은 문제에서 구할 수 있을때 만족합니다.



### Overlapping Subproblem

문제가 겹쳐야 하는데, 작은 문제가 겹쳐야 합니다.

**Dynamic Programing (=DP)**는 줄여서 푸는게 핵심입니다.

#### 피보나치

- F(0) = 0

- F(1) = 1

- F(n) = F(n-1) + F(n-2)

- 0,1,2,3,5,8,13,21….

  ​

##### 피보나치의 문제

F(N)

##### 피보나치의 작은 문제

- F(n-1) 
- F(n-2)

를 보아, 문제를 작은 문제로 만들었습니다. 



Overlapping 은 이제 이런 작은 문제가 겹쳐야 하는데요. 

F(n-1) = F(n-2) + F(n-3)

F(n-2) = F(n-3) + F(n-4)

에서 **F(n-2)**와 **F(n-3)** 이 겹치네요. 

따라서 

### Overlapping Subproblem 은

- 큰 문제와 작은 문제를 같은 방법으로 풀 수 있습니다.
- 문제를 작은 문제로 쪼갤 수 있습니다. 



### Optimal Substructure

문제의 정답을 작은 문제의 정답에서 구할 수 있습니다. 

##### 예시 - 서울 ~ 부산을 가는 빠른 길

- 서울 ~ 부산을 가는 가장 빠른 길이 대전과 대구를 거친다면,
  - 서울 -> 대전 -> 대구 -> 부산  
- 대전 ~ 부산을 가는 가장 빠른 길은 대구를 거쳐야 합니다. 
  - 대전 -> 대구 -> 부산
- 만약에 대전~부산을 가는 빠른길이 대전 -> 울산 -> 부산이 되면,, 서울 ~ 부산의 길은
  - 서울 -> 대전 -> 울산 -> 부산 이 됩니다.
- 따라서 , 작은 문제의 정답을 더하는 것으로, 문제의 정답이 변하게 됩니다.
- 문제의 크기에 상관없이, 한 문제의 정답은 일정해집니다. 
- 10번째 피보나치의 수를 구할때 4번째 피보나치 수 = 5번째 피보나치 수를 구할 때 4번째 피보나치의 수 

이렇다면, 정답을 한번 구했을 때, 다시 구할 필요가 없어집니다.

따라서 정답을 한번 구했을 경우, 정답을 어딘가에 메모해 둡니다.

이것을 **Memoization** 이라고합니다.



##### Memoization

정답을 구한 경우, 배열에 저장하는 방식으로 구현합니다. 



#### 피보나치의 수 

- f0 = 0
- f1 = 1

```java
int fibonacci(int n){
  if(n <=1){
    return n;
  }else{
    return fibonacci(n-1) + fibonacci(n-2)
  }
}
```

이 경우, 함수마다 거치기 때문에

f(5)의 경우

f(3)까지가 f(4),f(3)에서 총 2번 접근하게 됩니다.  중복이 되는것이죠. 

이런 중복을 제거하기 위해 , **Memoization** 을 사용합니다. 

```java
int memo[100];
int fibonacci(int n){
  if(n <=1){
    return n;
  }else{
    // memo 의 값이 0 보다 크면 배열 값 리턴으로 memoization 사용 
    if(memo[n]>0){
      return memo[n];
    }
    return fibonacci(n-1) + fibonacci(n-2)
  }
}
```



## 다이나믹 프로그래밍을 푸는 두가지 방법

### - TOP-DOWN

1. 문제를 푼다
   - fibonacci(n)
2. 문제를 작은 문제로 나눈다.
   - fibonacci(n-1) ,  fibonacci(n-2) 로 나눈다.
3. 작은 문제를 푼다.
   - fibonacci(n-1) ,  fibonacci(n-2) 를 호출해 문제를 푼다.
4. 작은 문제를 풀었으니, 이제 문제를 푼다.
   - fibonacci(n-1) ,  fibonacci(n-2) 의 값을 구해 문제를 푼다.

이방식은 시간 복잡도를 계산하는 방식이 조금 까다롭습니다.

시간복잡도 = 채워야 하는 칸의 수 (메모 배열에 몇개가 채워짐? ) * 1칸을 채우는 복잡도

TOP-DOWN  은 함수 하나가, 한 칸을 채우는 부분이기때문에 함수의 복잡도를 구하면 됩니다.

```java
// 시간 복잡도 알아보기
// 1. memo[n]을 채우기 복잡도 = O(N)
// 2. 함수의 연산 -> + 밖에 없다 = O(1)
// 따라서 fibonacci - top down 방식의 시간 복잡도는 O(N) 입니다.
int memo[100];
int fibonacci(int n){
  if(n <=1){
    return n;
  }else{
    if(memo[n]>0){ // 
      return memo[n];
    }
    return fibonacci(n-1) + fibonacci(n-2)
  }
}
```



### - BOTTOM-UP

1. 문제를 크기가 작은 문제부터 차례대로 푼다.
2. 문제의 크기를 조금씩 크게 만들어서 문제를 점점 풉니다.
3. 작은 문제를 풀면서 왔기 때문에, 큰 문제를 항상 풀 수 있습니다.
4. 그러다 보면 언젠가 풀어야 하는 문제를 풀 수 있습니다.

작은 문제부터풀고, 작은 문제를 풀면서 올라가면 큰 문제를 풀 수 있습니다.

#### Bottom-up 방식으로 푼 피보나치

```java
int d[100];
int fibonacci(int n){
  d[0] = 0;
  d[1] = 1;
  // 제일 작은 문제 2 부터 푼다.
  for(int i = 2; i<=n;i++){
    d[i] = d[i-1]+d[i-2];
  }
  return d[n];
}
```



### 문제풀이 전략

DI  문제를 어떻게 전략하는게 좋을까요?

memo[i] = i 번째 피보나치의 수로 표현했습니다.

보통은 다이나믹 표현에는,

d[i] , di[i] 로 표현을 하는데요. 

d[i] 에 **무엇이 들어가야하는지** 를 정의해 줍니다.

d[i] = i 번째 피보나치의 수가 들어가는지 정의해 줍니다. 

피보나치의겨우

d[i] 에는 **i-1 번쨰 피보나치의 수**와, **i-2 번째 피보나치의 수**가 더해져야 되는걸 알 수 있습니다.



 i-1 번쨰 피보나치의 수는 d[i-1]로,

i-2 번째 피보나치의 수는 d[i-2]로 표현할 수 있기 때문에

d[i] = d[i-1] + d[i-2] 라는 점화식으로 만들 수 있기 때문에,

이 다음은 점점 테이블을 채워나가면 됩니다.



#### topdown? bottom up?

처음에는 자신이 편한 방식으로 풀면 됩니다. 

재귀가 편하면 재귀를, for 가 편하면 for 를 사용합니다.

문제를 풀면서 차근차근 익히는게 좋습니다.