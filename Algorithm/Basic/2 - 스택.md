# 자료구조 1 - 스택

```
1. 스택
2. 스택을 이용해 풀 수 있는 문제
3. 큐
4. 큐를 이용해 조 세퍼스 문제 풀어보기
5. 덱
6. 문자열
```



## 스택

- 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 구조
- LIFO
- push: 스택에서 자료를 넣는 연산
- pop: 스택에서 자료를 빼는 연산
- top : 가장 위에 있는 자료를 보기
- empty: 스택이 비어있는지 아닌지 알아보는 연산
- size: 스택에 저장되어있는 자료의 개수를 알아보는 연산



## 스택 라이브러리

##### C++

 STL의 Stack

##### JAVA

java.util.Stack



## 스택 직접 짜기 위해서는

- 배열을 이용해 구현한다. 

- 스택이 몇개인지 size() 라는 변수가 필요하다.

- push를 한경우 size() 위치에 넣고 사이즈를 키운다.

  ```java
  push(){
  stack[size] = v;
  size ++;
  }
  ```

- pop 의 경우 `size-1` 번째의 코드를 지운다

  ```
  pop(){
    stack[size-1] = 0;
    size--;
  }
  ```



스택을 이용해 3가지 문제를 풀어봅시다.

### 1. 괄호

괄호 문자열이 주어졌을때, 올바른 괄호 문자열인지 아닌지를 알아봅시다.

- 올바른 괄호문자열: () 이 쌍으로 되어있는 경우
- 올바르지 않은 경우
  - `(()(` // 닫는 괄호 부재
  - `(())()))` // 여는 괄호 부재
  - `(()` // 닫는 괄호 부재 

##### 닫는 괄호의 입장에서 짝이 맞는 여는 괄호는?

1. 짝이 맞는 여는 괄호는 왼쪽에 있어야 합니다.
2. 아직 짝이 맞지 않아야 합니다.
3. 가장 오른쪽에 있는 괄호여야 합니다..(?)

##### 시간 복잡도 O(N^2)

모든 문자에 대해서 검사를 한번씩 수행합니다. 

여는 괄호는 넘어갑니다 (`O(N1)`)

닫는괄호는 왼쪽을 살펴바야합니다.

운이좋으면 1번, 안좋으면 왼쪽 끝까지 **N**번 

문자열은 **N**번이니 **N^2**!

##### 스택을 사용하면

1. 2번에 해당하는 여는 괄호를 스택에 넣어줍니다. 
2. 스택에 있는 괄호는 여는 괄호를 접근하기 때문에 **O(1)** 입니다.

```
시간 복잡도가 어떻게 1이 되지!? 했는데
스택을 사용하면, 변수에 직접 접근해서 처리하기때문에 
변수직접접근 = O(1) 이므로 가능하다고 한다!
또한 공통된짝이 안맞을 경우 바로 return 되니까!
```



#### 알고리즘

1. `(`가 나오면 스택에 넣고
2. `)`가 나오면 스택에서 하나를 빼서` (` 인지 확인합니다.
3. 또는 하나를 뺄 수 있는지 확인합니다.
4. `)` 가 나왔는데 스택이 비어있을 경우, 잘못된 괄호 문자열 입니다.
5. 모든 과정이 끝났는데 스택이 차있는경우, 잘못된 괄호 문자열 입니다. 
6. 그런데 생각해보면, 스택에 들어가는게 여는 괄호만 들어갑니다. 스택에 여는 괄호가 아닌, 몇개가 들어가는지가 중요하기 때문에 `cnt` 값을 이용해 풉니다.



### 2. 쇠막대기

- 레이저를 여는괄호와 닫는 괄호의 인접한 쌍으로 표현합니다.
- 인접하지 않은 경우는 쇠막대기라고 했을때, 레이저가 쇠막대기를 몇등분 하는지 리턴하기.

##### 스택을 사용하기

1. 스택을 넣는데, 인접 괄호를 구분해야한다.
2. 따라서 여는 괄호의 index 를 넣어줍니다.
3. 닫는 괄호를 만났는데, 여는 괄호의 `index` 와 `top` 차이가 1이라면 레이저입니다.
4. 그럼 스택에 있는 사이즈 만큼의 막대기가 생성됩니다.
5. 닫는 괄호를 만났는데, 여는괄호가 `index` `top` 차이가 없다면 쇠 막대기인경우도 1을 더해줍니다.

 ```
# 숨니 만의 수도 코드
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
( ) ( ( ( ( ) ( ) ) ( ( ) ) ( ) ) ) ( ( ) )

0 push size:1 top:1
1 pop  size:0 top:0

2 push size:1 top:2
3 push size:2 top:3
4 push size:3 top:4
5 push size:4 top:5
6 pop(5) -> diff 1 lazer pass size:3 bar+=3
7 push size:4 top:7
8 pop size:3 diff 1 lazer pass bar+=3
9 pop size:2 top 5 diff 3 bar+=1
0 push size:3 top:10
1 push size:4 top:11 
2 pop size:3 diff 1 lazer pass top:10 bar+=3
3 pop size:2 top:7 diff 3 bar+=1
4 push size:3 top:14
5 pop size:2 diff 1 lazer pass bar+=2
6 pop size:1 diff 13 bar+=1
7 pop size:0 diff 15 bar+=1
8 push size:1 top:18
9 push size:2 top:19
0 pop diff1 pop size:1 bar+=1
1 pop diff 3 bar+=1 
 ```



### 3. 에디터

한줄짜리 에디터를 시뮬레이션 하는 문제.

- L: 커서 왼쪽 **O(1)**
- R: 커서 오른쪽 **O(1)**
- B: 커서 왼쪽 삭제**O(N)**
- P $: $라는 문자를 커서 오른쪽에 추가합니다. **O(N)**

##### 경우 따져보기 

1. abc|xyz 일 경우
2. d 옮기면
3. ab|cxyz 
4. d 를 사용하면
5. a|cxyz
6. p d 를 사용
7. adcxyz

문자열 N * **O(N)** = N 60만 = 3600억 

못푼다..



##### 스택을 사용한 알고리즘

1. 커서를 기준으로 왼쪽스택 / 오른쪽스택을 나눕니다.
2. **L** 의 경우,**O(1)**
   1. 왼쪽 stack pop
   2. 오른쪽 stack 으로 push
3. **R** 의 경우,**O(1)**
   1. 오른쪽 stack pop
   2. 왼쪽 stack push
4. **D**의 경우**O(1)**
   1. pop!
5. **P $ **경우 **O(1)**
   1. 왼쪽 스택에 새로운 글자 push()
6. 스택 top 부터 출력하기위해, 왼쪽 스택을 오른쪽 스택에 push 해야한다. (**LIFO**)





#### 스택의 특징

가장 가까운 것을 **O(1)**만에 찾을 수 있습니다.

커서문제도 제일 가까운게 의미가 있다! 에 의미가 있어 사용했습니다.



##### 알고리즘 관련 문제

9012,10799,1406